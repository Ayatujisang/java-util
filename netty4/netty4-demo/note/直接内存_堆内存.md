
#### 基础知识
* [Java 并发编程之 NIO 简明教程](http://mp.weixin.qq.com/s/MlWir1tJARx5UN_SS6iSHQ)
* [堆外内存之 DirectByteBuffer 详解](http://mp.weixin.qq.com/s/PdGO53sPT0ZyfHJXkzTMqA)


```
1. 堆内存(HeapByteBuf) 字节缓冲区：特点是内存的分配和回收速度快，可以被jvm自动回收；
    缺点是如果进行socket的IO读写，需要额外做一次内存复制，将堆内存对应的缓冲区复制到内核Channel中年，
    性能会有一定程度的下降。

2. 直接内存（DirectByteBuf）字节缓冲区：非堆内存它在堆外进行内存分配，相比于堆内存，它的分配和回收速度回更慢一些，
    但是它写入或者从SocketChannel中读取时，由于少了一次内存复制，速度比堆内存快。

经验表明，ByteBuf的最佳实践是IO通讯线程的读写缓冲区使用DirectByteBuf，后端业务消息的编解码模块使用HeapByteBuf。

```

#### 垃圾回收
```
1. direct ByteBuffer通过full gc来回收内存的，direct ByteBuffer会自己检测情况而调用system.gc()，
但是如果参数中使用了DisableExplicitGC那么就无法回收该快内存了，-XX:+DisableExplicitGC标志自动将System.gc()调用转换成一个空操作，
就是应用中调用System.gc()会变成一个空操作。

2. 除了FULL GC外，CMS GC会回收Direct ByteBuffer的内存,CMS主要是针对old space空间的垃圾回收。

3. direct ByteBuffer可以通过-XX:MaxDirectMemorySize 来设置，此参数的含义是当Direct ByteBuffer分配的堆外内存到达指定大小后，即触发Full GC。默认64M。
```

#### 使用场景
```
1:多用网络编程中用到，实现zero copy,数据不需要再native memory和jvm memory中来回copy

2:由于造和析构Direct Buffer时间成本高，建议使用缓冲池，参见netty的实现
```